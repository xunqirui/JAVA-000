# 分布式缓存总结

## 为什么要用缓存

1. 高性能
2. 高并发

## 缓存常见问题

1. 缓存穿透

   大量并发查询不存在的 KEY，导致都直接将压力透传到数据库。

   解决方法：

   1. 缓存空置的 KEY，这样第一次不存在也会被加载会记录，下次拿到有这个 KEY。
   2. Bloom 过滤或 RoaringBitmap 判断 KEY 是否存在
   3. 完全以缓存为准，使用延迟异步加载的策略，异步线程负责维护缓存的数据，定期或根据条件触发更新

2. 缓存击穿

   某个 KEY 失效的时候，正好有大量并发请求访问这个 KEY。

   解决方法：

   1. KEY 的更新操作添加全局互斥锁
   2. 完全以缓存为准，使用延迟异步加载的策略，异步线程负责维护缓存的数据，定期或根据条件触发更新

3. 缓存雪崩

   当某一时刻发生大规模的缓存失效的情况，会有大量的请求进来直接打到数据库，导致数据库压力过大甚至宕机

   解决方法：

   1. 更新策略在时间上做到比较均匀。
   2. 使用的热数据尽量分散到不同的机器上
   3. 多台机器做主从复制或多副本，实现高可用
   4. 实现熔断限流机制，对系统进行负载能力控制

4. 缓存与数据库双写不一致问题

5. 缓存并发竞争

## Redis

### redis 的线程模型

redis 内部使用文件事件处理器 `file event handler`，这个文件事件处理器是单线程的，所以 redis 才叫做单线程的模型。它采用 IO 多路复用机制同时监听多个 socket，将产生事件的 socket 压入内存队列中，事件分派器根据 socket 上的事件类型来选择对应的事件处理器进行处理。

文件事件处理器的结构包含 4 个部分：

- 多个 socket
- IO 多路复用程序
- 文件事件分派器
- 事件处理器（连接应答处理器、命令请求处理器、命令回复处理器）

多个 socket 可能会并发产生不同的操作，每个操作对应不同的文件事件，但是 IO 多路复用程序会监听多个 socket，会将产生事件的 socket 放入队列中排队，事件分派器每次从队列中取出一个 socket，根据 socket 的事件类型交给对应的事件处理器进行处理。

![redis-single-thread-model](redis-single-thread-model.png)

### redis 单线程模型效率高的原因

- 纯内存操作。
- 核心是基于非阻塞的 IO 多路复用机制。
- C 语言实现，一般来说，C 语言实现的程序“距离”操作系统更近，执行速度相对会更快。
- 单线程反而避免了多线程的频繁上下文切换问题，预防了多线程可能产生的竞争问题。

### redis 的5中基本数据结构

1. 字符串（string）
2. 散列（hash）
3. 列表（list）
4. 集合（set）
5. 有序集合（sorted set）

### redis 的3中高级数据结构

1. Bitmaps
2. Hyperloglogs
3. GEO（存储地理位置）

### redis 六大使用场景

1. 业务数据缓存
2. 业务数据处理
3. 全局一致计数
4. 高效统计计数
5. 发布订阅与 Stream
6. 分布式锁

### redis 持久化的两种方式

#### RDB

rdb 是对 redis 中的数据执行周期性的持久化，周期性的生成一份 redis 内存中的数据的完整快照

由于是周期性生成多个数据文件的方式，比较适合做冷备，并且相较于 AOF 的持久化机制来说，恢复速度更快，但是由于是周期性的，如果 redis 一旦宕机，而此时并没有执行周期性的备份，则会丢失一部分时间的数据

#### AOF

AOF 机制对每条写入命令作为日志，已 append-only 的模式写入一个日志文件中

1. AOF 可以更好的保护数据不丢失，一般采用每秒通过一个后台线程执行一次 fsync 操作
2. AOF 以 append-only 的模式写入，没有磁盘寻址的开销，写入性能高
3. 当 AOF 的日志文件过大的时候，会触发重写操作
4. 对于同一份数据，AOF 会比 RDB 的数据大
5. 开启 AOF 后，QPS 会比 RDB 低

#### 选择

可以将 RDB 和 AOF 都开启

### redis 高可用

1. 主从架构
2. 基于哨兵+主从架构